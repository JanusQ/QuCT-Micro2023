'''Make sure that the circuit matches the hardware contraint'''
import random
from qiskit import QuantumCircuit, transpile
import numpy as np
from collections import defaultdict
max_qubit_num = 5

default_basis_gates = ['rx', 'ry', 'rz', 'cz']  # 'h',  # ['u', 'cz'] #
default_basis_single_gates =  ['rx', 'ry', 'rz']  #'h',  #['u'] #
default_basis_two_gates = ['cz']

single_gate_time = 30
double_gate_time = 60


# basis_gates = ['rx', 'ry', 'rz', 'cz'] #'h', 
# basis_single_gates = ['rx', 'ry', 'rz'] #'h', 
# basis_two_gates = ['cx']


# def index2pos(index):
#     '''q0 -> q(0,0)'''
#     return

# def pos2index(pos):
#     '''q(0,0) -> q0'''
#     return


# 先假设一维链吧
# coupling_map = [[q, q+1] for q in range(max_qubit_num-1)]
# [[0, 1], [1, 2], [2, 3], [3, 4],
#                 [4, 5], [5, 6], [6, 7], [7, 8], [8, 9]]

# single_qubit_fidelity = {0: 0.9913622807812399, 1: 0.9995459228523204, 2: 0.9992075629185534, 3: 0.9983283657689342,
#                          4: 0.9903143081867356, 5: 0.9977550549915091, 6: 0.995788376970502, 7: 0.9971490825344018, 8: 0.9994070174215289, 9: 0.9943473868359441}
# single_qubit_fidelity = defaultdict(lambda: 1)

# initial_layout = list(range(max_qubit_num))

# two_qubit_fidelity = {(0, 1): 0.9843107156710624, (1, 2): 0.9820908660885013, (2, 3): 0.9992926991023456, (3, 4): 0.9961834312102361, (
#     4, 5): 0.9977736740721713, (5, 6): 0.9960065327834351, (6, 7): 0.9863462286778378, (7, 8): 0.9851131078808855, (8, 9): 0.9828325041486045}
# two_qubit_fidelity = defaultdict(lambda : 1)

# T1 = 0
# T2 = 0

# single_qubit_fidelity = [
#     1 - random.random()/1000
#     for q in range(max_qubit_num)
# ]

# two_qubit_fidelity = [
#     1 - random.random()/500
#     for i, coupler in enumerate(coupling_map)
# ]

# qubit2T1 = [
#     110 - random.random() * 20
#     for q in range(max_qubit_num)
# ]

# qubit2T2 = [
#     7 - random.random() * 3
#     for q in range(max_qubit_num)
# ]


# [array([0.9868, 0.0132]), array([0.0384, 0.9616])]
# readout_error = {}
# for q in range(max_qubit_num):
#     prob0 = 1 - random.random() / 1000
#     prob1 = 1 - random.random() / 1000
#     readout_error[q] = [[prob0, 1-prob0], [1-prob1, prob1]]
# print(readout_error)
# readout_error = {0: [[0.9997289825718436, 0.00027101742815638374], [0.0005663901958417039, 0.9994336098041583]], 1: [[0.9997666345607157, 0.00023336543928431652], [0.0001971718498421371, 0.9998028281501579]], 2: [[0.9990599227212701, 0.0009400772787299116], [0.0009541091237041943, 0.9990458908762958]], 3: [[0.9997119127880099, 0.0002880872119901401], [0.0007829365938625266, 0.9992170634061375]], 4: [[0.999879954538188, 0.0001200454618119906], [0.000341313221804751, 0.9996586867781952]], 5: [
#     [0.9990846970315593, 0.0009153029684406677], [0.0003017038596752064, 0.9996982961403248]], 6: [[0.9999667203032807, 3.327969671929054e-05], [0.0004994612931629172, 0.9995005387068371]], 7: [[0.9996064401444854, 0.0003935598555145914], [0.00048244363749028185, 0.9995175563625097]], 8: [[0.9999205459873903, 7.945401260966989e-05], [0.0003805980986593127, 0.9996194019013407]], 9: [[0.9991987990630121, 0.0008012009369878781], [0.0008687035864336501, 0.9991312964135663]]}

readout_error = defaultdict(lambda: [[1,0], [0,1]])

# print(single_qubit_fidelity)
# print(two_qubit_fidelity)
# print(qubit2T1)
# print(qubit2T2)

# 门fidelity这里指指pauli error
# single_qubit_fidelity = [0.9999045459123782, 0.999993998477521, 0.9999203821649257, 0.9999097225882592, 0.9999835368519017, 0.999945834555963, 0.9999044089696233, 0.9999895668638996, 0.9999437426941443, 0.9999598264825013, 0.9999672333198566, 0.999930668226804, 0.9999034770946981, 0.9999532144857479, 0.9999191274712617]
# two_qubit_fidelity = [0.9991277269358018, 0.9999005438223685, 0.9992351286773069, 0.9990868946841714, 0.9999972729638725, 0.9991311578024596, 0.999866296295036, 0.9998984133016123, 0.9990404257344864, 0.9999897733719738, 0.9994383504625293, 0.9990970637918091, 0.9997425870417785, 0.9995213813800252]
# qubit2T1 = [97.76308440687052, 99.99113051730482, 105.24637722763265, 108.45265316013915, 95.18393503640621, 95.23580491208511, 91.18892318977583, 96.7156816015607, 107.170160865038, 90.9878538358554, 95.55594225137354, 107.31271525688871, 105.27490476607187, 99.71899663558527, 107.04489762758062]
# qubit2T2 = [6.83493913422518, 6.115042682836322, 6.535554277470392, 5.193690624099242, 5.328274782674233, 4.96880532697236, 5.066154697864669, 6.347766791753576, 6.2632342869243764, 4.494007346902143, 6.671568824350217, 6.68375618404517, 5.930464180699635, 6.702105315033936, 4.501073448242946]

single_qubit_fidelity = [0.9998373044948593, 0.9991926792661302, 0.9991638276238237, 0.9994240271116658, 0.9999059265129894, 0.9999923189579667, 0.9998712924694796, 0.9998549167994789, 0.9994025630221398, 0.9996103907259408, 0.9993980505169333, 0.9995232026010895, 0.9991565153561011, 0.9992060371240352, 0.999308357202824]
two_qubit_fidelity = [0.9986643521295939, 0.999957642113306, 0.999201085904397, 0.9986515495554109, 0.998392402747974, 0.9998345198845333, 0.9983458701522393, 0.9993869233144627, 0.9994058232685821, 0.9989982928387114, 0.9992364758374109, 0.9980563845681244, 0.9988999048128585, 0.9999438781001923]
qubit2T1 = [98.56222048408314, 109.99799249936929, 91.0361170461197, 101.65251251833344, 95.46730460546542, 109.45144734473058, 96.49982330149778, 106.44144011444862, 94.42939750061399, 108.15426591625064, 101.19712812877871, 98.61179043768054, 106.72578862238844, 98.91091051100668, 94.95548507062747]
qubit2T2 = [6.218568594109152, 5.815100065135997, 4.92364541017952, 5.9798809568407165, 6.943914157206011, 5.397044959004634, 5.646143239044738, 5.279441087726381, 5.233246388699668, 4.0751146056487775, 5.436583373033524, 5.765002752282516, 6.472977260061402, 5.638010077818899, 4.295342528641189]

def match_hardware_constraints(circuit: QuantumCircuit) -> bool:
    assert circuit.num_qubits <= max_qubit_num

    two_qubit_gates = circuit.get_instructions(default_basis_two_gates[0])
    for gate in two_qubit_gates:
        operated_qubits = [_.index for _ in gate.qubits]
        operated_qubits.sort()
        gate_type = gate.operation.name
        assert gate_type in default_basis_two_gates
        assert operated_qubits in coupling_map  # satisfy the processor topology

    return True

def fix_transpile(circuit: QuantumCircuit, ) -> QuantumCircuit:
    match_hardware_constraints(circuit)
    return transpile(circuit, basis_gates=basis_gates, coupling_map=coupling_map, initial_layout=initial_layout, optimization_level=0)
